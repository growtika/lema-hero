<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lema Hero - Hybrid Animation</title>

    <!-- GSAP CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        /* ============================================
           RESET & BASE STYLES
        ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #F5F3F0;
        }

        /* ============================================
           LOADING STATE
        ============================================ */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #F5F3F0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loader.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* ============================================
           HERO WRAPPER - Contains all phases
        ============================================ */
        .hero-wrapper {
            position: relative;
            width: 100%;
            height: 300vh; /* 3 phases x 100vh each */
        }

        /* ============================================
           HERO SECTION - Sticky container
        ============================================ */
        .hero-section {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        /* ============================================
           CANVAS STYLES
        ============================================ */
        .hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* ============================================
           TEXT OVERLAYS - Common Styles
        ============================================ */
        .hero-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            pointer-events: none;
        }

        .hero-overlay.active {
            display: flex;
            pointer-events: auto;
        }

        .hero-content {
            text-align: center;
            max-width: 720px;
            padding: 0 1rem;
        }

        .hero-label {
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .hero-headline {
            font-size: 3rem;
            font-weight: 600;
            line-height: 1.1;
            margin-bottom: 1.25rem;
            letter-spacing: -0.02em;
        }

        .hero-subtext {
            font-size: 1rem;
            line-height: 1.65;
            max-width: 580px;
            margin: 0 auto;
            font-weight: 400;
        }

        .hero-cta {
            display: inline-block;
            margin-top: 1.75rem;
            padding: 0.875rem 2rem;
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            border-radius: 3px;
            transition: transform 0.2s ease, opacity 0.2s ease;
            pointer-events: auto;
        }

        .hero-cta:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }

        /* ============================================
           PHASE 1 - Light Background, Dark Text
        ============================================ */
        .overlay-phase1 .hero-content {
            color: #3D2314;
        }

        .overlay-phase1 .hero-subtext {
            color: rgba(61, 35, 20, 0.75);
        }

        .overlay-phase1 .hero-cta {
            background: #3D2314;
            color: #F5F3F0;
        }

        /* ============================================
           PHASE 2 - Dark Background, White Text
        ============================================ */
        .overlay-phase2 .hero-content {
            color: #FFFFFF;
        }

        .overlay-phase2 .hero-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .overlay-phase2 .hero-subtext {
            color: rgba(255, 255, 255, 0.8);
        }

        /* ============================================
           PHASE 3 - Light Background, Dark Text
        ============================================ */
        .overlay-phase3 .hero-content {
            color: #3D2314;
        }

        .overlay-phase3 .hero-subtext {
            color: rgba(61, 35, 20, 0.75);
        }

        /* ============================================
           PHASE INDICATORS
        ============================================ */
        .phase-indicators {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(61, 35, 20, 0.25);
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .phase-dot:hover {
            transform: scale(1.3);
        }

        .phase-dot.active {
            background: #3D2314;
        }

        /* Dark phase indicators */
        .hero-section.dark-phase .phase-dot {
            background: rgba(255, 255, 255, 0.3);
        }

        .hero-section.dark-phase .phase-dot.active {
            background: #FFFFFF;
        }

        /* ============================================
           SCROLL HINT - Hidden by default
        ============================================ */
        .scroll-hint {
            display: none;
        }

        /* ============================================
           RESPONSIVE - Tablet
        ============================================ */
        @media (max-width: 1024px) {
            .hero-headline {
                font-size: 2.5rem;
            }

            .hero-subtext {
                font-size: 0.95rem;
                max-width: 500px;
            }

            .hero-content {
                max-width: 600px;
            }
        }

        /* ============================================
           RESPONSIVE - Mobile
        ============================================ */
        @media (max-width: 768px) {
            .hero-overlay {
                padding: 1rem;
            }

            .hero-content {
                max-width: 100%;
                padding: 0 0.5rem;
            }

            .hero-label {
                font-size: 0.65rem;
                letter-spacing: 0.15em;
                margin-bottom: 0.5rem;
            }

            .hero-headline {
                font-size: 1.75rem;
                margin-bottom: 1rem;
            }

            .hero-subtext {
                font-size: 0.875rem;
                line-height: 1.6;
            }

            .hero-cta {
                padding: 0.75rem 1.5rem;
                font-size: 0.85rem;
                margin-top: 1.25rem;
            }

            .phase-indicators {
                bottom: 1.5rem;
            }

            .phase-dot {
                width: 7px;
                height: 7px;
            }
        }

        /* ============================================
           RESPONSIVE - Small Mobile
        ============================================ */
        @media (max-width: 480px) {
            .hero-headline {
                font-size: 1.5rem;
            }

            .hero-subtext {
                font-size: 0.8rem;
            }
        }

        /* ============================================
           CONTENT AFTER HERO (placeholder)
        ============================================ */
        .content-section {
            padding: 100px 20px;
            background: #fff;
            text-align: center;
            min-height: 50vh;
        }

        .content-section h2 {
            font-size: 2rem;
            color: #3D2314;
            margin-bottom: 1rem;
        }

        .content-section p {
            color: #666;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Loading Screen (hidden) -->
    <div class="loader hidden" id="loader"></div>

    <!-- Hero Wrapper - 300vh tall for natural scrolling -->
    <div class="hero-wrapper" id="heroWrapper">
        <!-- Hero Section - Sticky -->
        <section class="hero-section" id="heroSection">
            <!-- Canvas for frame animation -->
            <canvas class="hero-canvas" id="heroCanvas"></canvas>

            <!-- PHASE 1 - Light Theme -->
            <div class="hero-overlay overlay-phase1 active" id="overlay1">
                <div class="hero-content">
                    <h1 class="hero-headline">Think outside the checkbox</h1>
                    <p class="hero-subtext">Turn your TPRM team into Risk Engineers who uncover what everyone else misses – evolving from compliance management to risk mitigation.</p>
                    <a href="#demo" class="hero-cta">Get a Demo</a>
                </div>
            </div>

            <!-- PHASE 2 - Dark Theme -->
            <div class="hero-overlay overlay-phase2" id="overlay2">
                <div class="hero-content">
                    <span class="hero-label">Third Parties</span>
                    <h1 class="hero-headline">Your new single point of failure</h1>
                    <p class="hero-subtext">TPRM used to be tough but manageable. We've lost control over Third-Party Sprawl. There are more third parties than ever before, and every AI tool is wired straight into the heart of your business – yet legacy TPRM treats them like static vendors.</p>
                </div>
            </div>

            <!-- PHASE 3 - Light Theme -->
            <div class="hero-overlay overlay-phase3" id="overlay3">
                <div class="hero-content">
                    <h1 class="hero-headline">The rise of the Risk Engineer</h1>
                    <p class="hero-subtext">Like a needle in a tech stack, vendor risk hides in endless data. Finding it means matching every artifact, control, and compliance doc. That's what Risk Engineers were born to do.</p>
                </div>
            </div>

            <!-- Scroll Hint -->
            <div class="scroll-hint" id="scrollHint">Scroll to skip</div>
        </section>
    </div>

    <!-- Content After Hero (placeholder) -->
    <section class="content-section">
        <h2>Welcome to Lema</h2>
        <p>Continue scrolling to explore more content. This section appears after the hero animation completes.</p>
    </section>

    <script>
        /* ============================================
           CONFIGURATION
        ============================================ */
        const CONFIG = {
            FRAME_PATH: './',
            FRAME_PREFIX: 'Lema_HP_Desktop_Kaleidoscope.',
            FRAME_EXTENSION: '.webp',
            TOTAL_FRAMES: 273,
            FRAME_PADDING: 5,

            // Phase frame ranges
            PHASES: [
                { start: 0, end: 106, textAt: 0 },       // Phase 1
                { start: 107, end: 207, textAt: 137 },   // Phase 2
                { start: 208, end: 272, textAt: 226 }    // Phase 3
            ],

            FRAME_DURATION: 33,             // ~30fps
            SCROLL_LOCK_DURATION: 1500,     // Lock during animation
        };

        /* ============================================
           DOM ELEMENTS
        ============================================ */
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loader');
        const heroSection = document.getElementById('heroSection');
        const heroWrapper = document.getElementById('heroWrapper');
        const overlays = [
            document.getElementById('overlay1'),
            document.getElementById('overlay2'),
            document.getElementById('overlay3')
        ];
        const phaseDots = document.querySelectorAll('.phase-dot');

        /* ============================================
           STATE
        ============================================ */
        const frames = [];
        let imagesLoaded = 0;
        let currentFrame = 0;
        let currentPhase = 0;
        let displayedPhase = 0; // Track which phase is currently displayed
        let rafId = null;
        let state = 'stopped';
        let lastScrollActionTime = 0;

        // Store the end frame for each completed phase (for scroll-back viewing)
        const phaseEndFrames = [
            CONFIG.PHASES[0].end,  // Phase 1 end frame
            CONFIG.PHASES[1].end,  // Phase 2 end frame
            CONFIG.PHASES[2].end   // Phase 3 end frame
        ];

        // Track which phases have been completed
        let completedPhases = [false, false, false];

        /* ============================================
           FRAME LOADING
        ============================================ */
        function getFramePath(index) {
            const paddedNumber = String(index).padStart(CONFIG.FRAME_PADDING, '0');
            return `${CONFIG.FRAME_PATH}${CONFIG.FRAME_PREFIX}${paddedNumber}${CONFIG.FRAME_EXTENSION}`;
        }

        function preloadFrames() {
            return new Promise((resolve) => {
                for (let i = 0; i < CONFIG.TOTAL_FRAMES; i++) {
                    const img = new Image();
                    img.onload = () => {
                        imagesLoaded++;
                        if (imagesLoaded === CONFIG.TOTAL_FRAMES) resolve();
                    };
                    img.onerror = () => {
                        imagesLoaded++;
                        if (imagesLoaded === CONFIG.TOTAL_FRAMES) resolve();
                    };
                    img.src = getFramePath(i);
                    frames[i] = img;
                }
            });
        }

        /* ============================================
           CANVAS RENDERING
        ============================================ */
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function renderFrame(frameIndex) {
            frameIndex = Math.max(0, Math.min(frameIndex, CONFIG.TOTAL_FRAMES - 1));
            const frame = frames[frameIndex];
            if (!frame) return;

            const canvasRatio = canvas.width / canvas.height;
            const frameRatio = frame.naturalWidth / frame.naturalHeight;

            let drawWidth, drawHeight, drawX, drawY;

            if (frameRatio > canvasRatio) {
                drawHeight = canvas.height;
                drawWidth = frame.naturalWidth * (canvas.height / frame.naturalHeight);
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            } else {
                drawWidth = canvas.width;
                drawHeight = frame.naturalHeight * (canvas.width / frame.naturalWidth);
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            }

            ctx.drawImage(frame, drawX, drawY, drawWidth, drawHeight);
        }

        /* ============================================
           PHASE MANAGEMENT
        ============================================ */
        function updatePhaseUI(phaseIndex) {
            overlays.forEach((overlay, i) => {
                if (i === phaseIndex) {
                    overlay.classList.add('active');
                } else {
                    overlay.classList.remove('active');
                }
            });

            phaseDots.forEach((dot, i) => {
                if (i === phaseIndex) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });

            if (phaseIndex === 1) {
                heroSection.classList.add('dark-phase');
            } else {
                heroSection.classList.remove('dark-phase');
            }

            displayedPhase = phaseIndex;
        }

        /* ============================================
           SCROLL POSITION TO PHASE MAPPING
           Maps scroll position within hero-wrapper to phase
        ============================================ */
        function getPhaseFromScroll() {
            const scrollTop = window.scrollY;
            const wrapperHeight = heroWrapper.offsetHeight;
            const viewportHeight = window.innerHeight;
            const scrollableHeight = wrapperHeight - viewportHeight;

            if (scrollableHeight <= 0) return 0;

            const scrollProgress = Math.min(1, Math.max(0, scrollTop / scrollableHeight));

            // Divide into 3 phases
            if (scrollProgress < 0.33) return 0;
            if (scrollProgress < 0.66) return 1;
            return 2;
        }

        /* ============================================
           ANIMATION ENGINE
        ============================================ */
        let lastFrameTime = 0;

        function scheduleNextFrame() {
            rafId = requestAnimationFrame(tick);
        }

        function tick(now) {
            if (state !== 'playing') return;

            const elapsed = now - lastFrameTime;
            if (elapsed >= CONFIG.FRAME_DURATION) {
                currentFrame++;

                const phaseEnd = CONFIG.PHASES[currentPhase].end;
                if (currentFrame > phaseEnd) {
                    currentFrame = phaseEnd;
                    renderFrame(currentFrame);

                    // Mark phase as completed
                    completedPhases[currentPhase] = true;

                    state = 'stopped';

                    // Prepare for next phase if exists
                    if (currentPhase < CONFIG.PHASES.length - 1) {
                        currentPhase++;
                        currentFrame = CONFIG.PHASES[currentPhase].start;
                        renderFrame(currentFrame);
                    }
                    return;
                }

                if (currentFrame >= CONFIG.TOTAL_FRAMES) {
                    currentFrame = CONFIG.TOTAL_FRAMES - 1;
                    completedPhases[currentPhase] = true;
                    state = 'stopped';
                    return;
                }

                renderFrame(currentFrame);
                lastFrameTime = now;

                const textAtFrame = CONFIG.PHASES[currentPhase].textAt;
                if (currentFrame === textAtFrame) {
                    updatePhaseUI(currentPhase);
                }
            }

            scheduleNextFrame();
        }

        function playCurrentPhase() {
            if (state === 'playing') return;
            state = 'playing';
            lastFrameTime = performance.now();
            scheduleNextFrame();
        }

        /* ============================================
           SCROLL HANDLING
        ============================================ */
        function handleWheel(e) {
            const scrollingDown = e.deltaY > 0;
            const now = Date.now();

            // Get current scroll-based phase
            const scrollPhase = getPhaseFromScroll();

            if (scrollingDown) {
                // SCROLL DOWN - Play animation if not completed
                if (state === 'playing') {
                    e.preventDefault();
                    return;
                }

                // If we haven't completed current phase, hijack and play
                if (!completedPhases[currentPhase]) {
                    if (now - lastScrollActionTime < CONFIG.SCROLL_LOCK_DURATION) {
                        e.preventDefault();
                        return;
                    }

                    e.preventDefault();
                    lastScrollActionTime = now;
                    playCurrentPhase();
                    return;
                }

                // Phase completed - allow natural scroll to next phase
                // Don't prevent default, let page scroll naturally
            } else {
                // SCROLL UP - Always natural, but update display based on scroll position
                // Don't prevent default - let browser handle scroll naturally

                // Update displayed frame based on which phase section we're in
                if (scrollPhase !== displayedPhase && completedPhases[scrollPhase]) {
                    // Show the end frame of the phase we scrolled back to
                    const frameToShow = phaseEndFrames[scrollPhase];
                    renderFrame(frameToShow);
                    updatePhaseUI(scrollPhase);
                    currentPhase = scrollPhase;
                    currentFrame = frameToShow;
                }
            }
        }

        /* ============================================
           SCROLL LISTENER FOR SCROLL-BACK UPDATES
        ============================================ */
        let lastScrollPhase = -1;

        function handleScroll() {
            const scrollPhase = getPhaseFromScroll();

            // Only update if phase changed
            if (scrollPhase === lastScrollPhase) return;
            lastScrollPhase = scrollPhase;

            // Update display when scrolling through phases
            // For completed phases, show their end frame
            // For uncompleted phases, show their start frame
            if (scrollPhase !== displayedPhase) {
                if (completedPhases[scrollPhase]) {
                    // Phase was completed - show end frame
                    const frameToShow = phaseEndFrames[scrollPhase];
                    renderFrame(frameToShow);
                    updatePhaseUI(scrollPhase);
                    currentPhase = scrollPhase;
                    currentFrame = frameToShow;
                } else if (scrollPhase < currentPhase) {
                    // Scrolling back to an uncompleted phase - show its start
                    const frameToShow = CONFIG.PHASES[scrollPhase].start;
                    renderFrame(frameToShow);
                    updatePhaseUI(scrollPhase);
                    currentPhase = scrollPhase;
                    currentFrame = frameToShow;
                }
            }
        }

        /* ============================================
           TOUCH HANDLING (Mobile)
        ============================================ */
        let touchStartY = 0;
        let touchStartTime = 0;

        function handleTouchStart(e) {
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
        }

        function handleTouchEnd(e) {
            const touchEndY = e.changedTouches[0].clientY;
            const deltaY = touchStartY - touchEndY;
            const deltaTime = Date.now() - touchStartTime;

            if (deltaY > 50 && deltaTime < 500) {
                // Swipe down - trigger animation if not completed
                if (!completedPhases[currentPhase] && state !== 'playing') {
                    lastScrollActionTime = Date.now();
                    playCurrentPhase();
                }
            }
        }

        /* ============================================
           EVENT LISTENERS
        ============================================ */
        function initEventListeners() {
            // Mouse wheel
            heroWrapper.addEventListener('wheel', handleWheel, { passive: false });

            // Scroll listener for scroll-back frame updates
            window.addEventListener('scroll', handleScroll, { passive: true });

            // Touch events
            heroWrapper.addEventListener('touchstart', handleTouchStart, { passive: true });
            heroWrapper.addEventListener('touchend', handleTouchEnd, { passive: true });

            // Window resize
            window.addEventListener('resize', () => {
                setCanvasSize();
                renderFrame(currentFrame);
            });

            // Visibility change
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && state === 'playing') {
                    state = 'stopped';
                    if (rafId) cancelAnimationFrame(rafId);
                }
            });
        }

        /* ============================================
           INITIALIZATION
        ============================================ */
        async function init() {
            setCanvasSize();
            await preloadFrames();
            renderFrame(0);
            updatePhaseUI(0);
            loader.classList.add('hidden');
            initEventListeners();

            // Auto-play Phase 1 on load
            setTimeout(() => {
                playCurrentPhase();
            }, 500);
        }

        init();
    </script>
</body>
</html>
